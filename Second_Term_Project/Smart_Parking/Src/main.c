/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "stm32f103x6.h"
#include "stm32_f103c6_gpio_drivers.h"
#include "stm32_f103c6_USART_drivers.h"
#include "Servo_Motor.h"
#include "lcd.h"
#include "keypad.h"

#define pir1		GPIO_PIN_7
#define pir2		GPIO_PIN_1

#define led_green	GPIO_PIN_11
#define led_red		GPIO_PIN_0

#define led_high	0
#define led_low		1

//Prototypes
void LEDS_Init(void);
void PIR_Init(void);
void clock_init(void);
void Welcome_message(void);
void print_slots_counter(void);
void UART1_UART2_Init(void);
void Admin_Set_IDs(void);

//Global Variables
LCD_Pins_Config_t LCD1 = {GPIOB,GPIOB,GPIOB,GPIOB,GPIO_PIN_11,GPIO_PIN_10};
LCD_Pins_Config_t LCD2 = {GPIOA,GPIOA,GPIOA,GPIOA,GPIO_PIN_5,GPIO_PIN_6};
char Allowed_ID[3], keypad_val = 0;
uint32_t slots_counter = 3;
char Recieve_Buffer1 , Recieve_Buffer2;


void Usart1_Handler_ISR(void)
{
	MCAL_UART_ReceiveData(USART1, &Recieve_Buffer1, disable);
	MCAL_UART_SendData(USART1, &Recieve_Buffer1, enable);
	if( (slots_counter != 0) && (MCAL_GPIO_ReadPin(GPIOA, pir1) == 0) )
	{
		//check if Entry ID is correct
		if((Recieve_Buffer1 == Allowed_ID[0]) || (Recieve_Buffer1 == Allowed_ID[1]) || (Recieve_Buffer1 == Allowed_ID[2]))
		{
			//decreament Empty spaces
			slots_counter--;
			//LCD print
			lcd_clear(&LCD2);
			lcd_write_string(&LCD2, "Correct ID");
			lcd_goto_xy(&LCD2,2,0);
			lcd_write_string(&LCD2, "Entry Gate Opens");
			//Green led Flashes
			MCAL_GPIO_WritePin(GPIOA, led_green, led_high);
			dms(100);
			MCAL_GPIO_WritePin(GPIOA, led_green, led_low);
			dms(100);
			//Entry Gate Servo_Motor Up
			Servo1_Entry_Gate(UP);
			dms(300);
			//wait for PIR sensor to be zero
			while(MCAL_GPIO_ReadPin(GPIOA, pir1) == 1);
			//Entry Gate Servo_Motor Down
			Servo1_Entry_Gate(Down);


		}
		//if Entry ID is Wrong
		else
		{
			lcd_clear(&LCD2);
			lcd_write_string(&LCD2, "Wrong ID");
			lcd_goto_xy(&LCD2,2,3);
			lcd_write_string(&LCD2, "Try Again");
			//Red led Flashes
			MCAL_GPIO_WritePin(GPIOA, led_red, led_high);
			dms(100);
			MCAL_GPIO_WritePin(GPIOA, led_red, led_low);
			dms(100);
		}
	}
	//No available slots
	else
	{
		lcd_clear(&LCD2);
		//check if parking is Full
		if(slots_counter == 0)
		{
			lcd_write_string(&LCD2, "No Empty Slots");
			dms(100);
		}
		//Check if Gate is still open
		else
		{
			lcd_write_string(&LCD2, "Please Wait");
			lcd_goto_xy(&LCD2,2,3);
			lcd_write_string(&LCD2, "Entry Gate");
			lcd_goto_xy(&LCD2,3,3);
			lcd_write_string(&LCD2, "Is Still Open");
			dms(100);
		}

	}
	Welcome_message();
}

void Usart2_Handler_ISR(void)
{
	MCAL_UART_ReceiveData(USART2, &Recieve_Buffer2, disable);
	MCAL_UART_SendData(USART2, &Recieve_Buffer2, enable);
	//check if EXIT ID is correct
	if( (slots_counter != 3) && (MCAL_GPIO_ReadPin(GPIOA, pir2) == 0) )
	{
		if((Recieve_Buffer2 == Allowed_ID[0]) || (Recieve_Buffer2 == Allowed_ID[1]) || (Recieve_Buffer2 == Allowed_ID[2]))
		{
			//increament slots spaces
			slots_counter++;
			//LCD print
			lcd_clear(&LCD2);
			lcd_write_string(&LCD2, "Correct ID");
			lcd_goto_xy(&LCD2,2,0);
			lcd_write_string(&LCD2, "Exit Gate Opens");
			//Exit Gate Servo_Motor Up
			Servo2_Exit_Gate(UP);
			dms(300);
			//wait for PIR sensor to be zero
			while(MCAL_GPIO_ReadPin(GPIOA, pir2) == 1);
			//Exit Gate Servo_Motor Down
			Servo2_Exit_Gate(Down);
		}
		//check if EXIT ID is Wrong
		else
		{
			lcd_clear(&LCD2);
			lcd_write_string(&LCD2, "Wrong ID");
			lcd_goto_xy(&LCD2,2,3);
			lcd_write_string(&LCD2, "Try Again");
			//Red led Flashes
			MCAL_GPIO_WritePin(GPIOA, led_red, led_high);
			dms(100);
			MCAL_GPIO_WritePin(GPIOA, led_red, led_low);
			dms(100);
		}
	}
	else
	{
		lcd_clear(&LCD2);
		//check if parking is empty
		if(slots_counter == 3)
		{
			lcd_write_string(&LCD2, "Parking Is Empty");
			dms(100);
		}
		//check if gate is still open
		else
		{
			lcd_write_string(&LCD2, "Please Wait");
			lcd_goto_xy(&LCD2,2,3);
			lcd_write_string(&LCD2, "Exit Gate");
			lcd_goto_xy(&LCD2,3,3);
			lcd_write_string(&LCD2, "Is Still Open");
			dms(100);
		}
	}
	Welcome_message();
}


int main(void)
{
	//Enable Clock
	clock_init();
	//Initialize all Drivers
	keypad_init();
	Servo1_Entry_Gate_Init();
	Servo2_Exit_Gate_Init();
	Timer2_init();
	UART1_UART2_Init();
	LEDS_Init();
	PIR_Init();
	lcd_init(&LCD1);
	lcd_init(&LCD2);
	//Start Entering Registered IDs
	Admin_Set_IDs();
	Welcome_message();
	while(1)
	{

	}
}



void LEDS_Init(void)
{
	//Green LED
	GPIO_Pinconfig_t pin_cfg;
	pin_cfg.PinNumber = led_green;
	pin_cfg.Mode = GPIO_MODE_Output_PP;
	pin_cfg.Output_speed = GPIO_SPEED_10M;
	MCAL_GPIO_Init(GPIOA, &pin_cfg);
	MCAL_GPIO_WritePin(GPIOA, led_green, 1);
	//Red LED
	pin_cfg.PinNumber = led_red;
	pin_cfg.Mode = GPIO_MODE_Output_PP;
	pin_cfg.Output_speed = GPIO_SPEED_10M;
	MCAL_GPIO_Init(GPIOA, &pin_cfg);
	MCAL_GPIO_WritePin(GPIOA, led_red, 1);
}


void PIR_Init(void)
{
	//pir1
	GPIO_Pinconfig_t pin_cfg;
	pin_cfg.PinNumber = pir1;
	pin_cfg.Mode = GPIO_MODE_Input_FLU;
	MCAL_GPIO_Init(GPIOA, &pin_cfg);
	//pir2
	pin_cfg.PinNumber = pir2;
	pin_cfg.Mode = GPIO_MODE_Input_FLU;
	MCAL_GPIO_Init(GPIOA, &pin_cfg);
}


void clock_init(void)
{
	//Enable clock for GPIOA
	RCC_GPIOA_CLK_EN();
	//Enable clock for GPIOB
	RCC_GPIOB_CLK_EN();
	//Enable clock for AFIO
	RCC_AFIO_CLK_EN();
}


void Welcome_message(void)
{
	lcd_clear(&LCD2);
	lcd_goto_xy(&LCD2, 1, 2);
	lcd_write_string(&LCD2, "Welcome in");
	lcd_goto_xy(&LCD2, 2, 3);
	lcd_write_string(&LCD2, "Parking");
	dms(100);
	lcd_clear(&LCD2);
	if(slots_counter != 0)
	{
		lcd_write_string(&LCD2, "Empty Slots: ");
		print_slots_counter();
		lcd_goto_xy(&LCD2, 2, 0);
		lcd_write_string(&LCD2, "Put Your ID in");
		lcd_goto_xy(&LCD2, 3, 0);
		lcd_write_string(&LCD2, "Card Reader");
		dms(100);
	}
	else
	{
		lcd_write_string(&LCD2, "Parking Is Full");
		dms(100);
	}

}

void print_slots_counter(void)
{
	if(slots_counter == 1)
		lcd_write_char(&LCD2, '1');
	else if(slots_counter == 2)
		lcd_write_char(&LCD2, '2');
	else if(slots_counter == 3)
		lcd_write_char(&LCD2, '3');
}

void UART1_UART2_Init(void)
{
	//initialize uart1
	USART_CONFIG_t UART_cfg1;
	UART_cfg1.USART_Mode = USART_MODE_TX_RX;
	UART_cfg1.BaudRate_Speed = UART_BAUDRATE_SPEED_115200;
	UART_cfg1.FLOW_CTRL = UART_FLOWCTRL_NONE;
	UART_cfg1.Parity = UART_PARITY_DISABLE;
	UART_cfg1.PayLoad_Data = UART_PAYLOAD_DATA_8BIT;
	UART_cfg1.IRQ_ENABLE = UART_IRQ_ENABLE_RXNE;
	UART_cfg1.Stop_bits = UART_STOP_BITS_1BIT;
	UART_cfg1.P_IRQ_CallBack = Usart1_Handler_ISR;
	MCAL_UART_Init(USART1, &UART_cfg1);
	MCAL_UART_GPIO_Set_Pins(USART1);
	//initialize uart2
	UART_cfg1.USART_Mode = USART_MODE_TX_RX;
	UART_cfg1.BaudRate_Speed = UART_BAUDRATE_SPEED_115200;
	UART_cfg1.FLOW_CTRL = UART_FLOWCTRL_NONE;
	UART_cfg1.Parity = UART_PARITY_DISABLE;
	UART_cfg1.PayLoad_Data = UART_PAYLOAD_DATA_8BIT;
	UART_cfg1.IRQ_ENABLE = UART_IRQ_ENABLE_RXNE;
	UART_cfg1.Stop_bits = UART_STOP_BITS_1BIT;
	UART_cfg1.P_IRQ_CallBack = Usart2_Handler_ISR;
	MCAL_UART_Init(USART2, &UART_cfg1);
	MCAL_UART_GPIO_Set_Pins(USART2);
}

void Admin_Set_IDs(void)
{
	lcd_write_string(&LCD1, "Enter IDS : ");
	//get Allowed IDs From Admin
	char str_arr[3][15] = {"First ID: ","Second ID: ","Third ID: "};
	int i;
	for(i=0; i<3; i++)
	{
		lcd_goto_xy(&LCD1, i+2, 0);
		lcd_write_string(&LCD1, str_arr[i]);
		//Get Keypad Value From Admin
		keypad_val = keypad_get_key();
		//Wait for Admin to enter each number in Keypad
		while(keypad_val == 'N')
		{
			keypad_val = keypad_get_key();
		}
		Allowed_ID[i] = keypad_val;
		lcd_write_char(&LCD1, Allowed_ID[i]);
	}
	dms(100);
	lcd_clear(&LCD1);
	lcd_write_command(&LCD1, display_on_cursor_off);
	lcd_write_command(&LCD2, display_on_cursor_off);
	//Print Entered IDs
	lcd_write_string(&LCD1, "IDS Are Saved");
	lcd_goto_xy(&LCD1,2,4);
	lcd_write_char(&LCD1, Allowed_ID[0]);
	lcd_goto_xy(&LCD1,2,8);
	lcd_write_char(&LCD1, Allowed_ID[1]);
	lcd_goto_xy(&LCD1,2,12);
	lcd_write_char(&LCD1, Allowed_ID[2]);
}







